####################################################
|exerciseicon__T| Exercici 02_23. És enter (modular)
####################################################

.. rubric:: Context

* Carpeta de lliurament: ``02_23_es_enter/``

* Continguts relacionats: :doc:`moduls_variables`

* Com lliurar-lo: :ref:`instruccions <instruccions_git>`

* [✓] Exercici amb :ref:`autoavaluació<descripcio_exercicis_autoavaluacio>`

.. rubric:: Enunciat

Recuperem l'exercici que mostrava si una cadena contenia o no :doc:`un
valor enter
<exercici_01_71_es_enter>` i fem-ne la versió modular

El programa ``EsEnter`` farà el mateix que la versió original però
els càlculs els realitzarà una funció anomenada ``esEnter()``, que rebrà
el text corresponent i retornarà un booleà amb el resultat.

``esEnter()`` estarà definida dins de ``UtilString.java`` i serà
una funció pura.

.. note::

    Un dels usos més interessants de ``esEnter()`` és que ens ofereix la
    possiblitat de saber si ``Integer.parseInt()`` funcionarà o no, abans
    d'executar-ho.

    Per exemple, considera:

    .. code-block:: console

        jshell> Integer.parseInt("   123  ")
        |  Exception java.lang.NumberFormatException: For input string: "   123  "
        |        at NumberFormatException.forInputString (NumberFormatException.java:65)
        |        at Integer.parseInt (Integer.java:638)
        |        at Integer.parseInt (Integer.java:770)
        |        at (#2:1)

    Per aquesta raó, no podem acceptar que ``esEnter()`` ignori els espais
    en blanc, tal i com sí s'esperava del programa ``EsEnter``.
    És a dir, la feina de treure-li els espais caldrà fer-la abans de fer servir
    ``esEnter()``.
