########################################################
|exerciseiconO_T| Exercici 03_11. Puzle d'escacs: mostra
########################################################

.. rubric:: Context

* Carpeta de lliurament: ``03_11_show/``

* Continguts relacionats: :doc:`exercici_03_08_puzles`

* Com lliurar-lo: :ref:`instruccions <instruccions_git>`

* [☼] Exercici :ref:`optatiu<descripcio_exercicis_optatius>`

* [✓] Exercici amb :ref:`autoavaluació<descripcio_exercicis_autoavaluacio>`

.. rubric:: Enunciat

Afegirem ara la funcionalitat de mostrar un puzle a partir del seu nom.

La comanda serà: ``show «nom»``

En cas que no es proporcioni el nom, es mostrarà el missatge ``ERROR: show
«nom»`` i tornarà a mostrar el *prompt*.

En cas que el nom proporcionat no sigui un nom vàlid de puzle, mostrarà el
missatge ``ERROR: nom no vàlid`` i tornarà al *prompt*..

Si el puzle no existeix, mostrarà el missatge ``ERROR: puzle desconegut``
i tornarà a mostrar el *prompt*.

En ser cridat, el mòdul escriurà per pantalla el contingut del taulell:

.. code-block:: none

    ········
    p·······
    ········
    ········
    ········
    ······PR
    ·····A··
    ·······r


Per passar les proves, caldrà que implementis els següents mòduls:

* ``processaShow(String[])``: donat un array amb les paraules que composen
  la comanda, realitza les comprovacions i mostra errors o el taulell
  corresponent.

  És el mòdul que, un cop se sap que la comanda és ``show`` realitza la
  feina corresponent a la comanda.

* ``composaNomFitxerDeNomPuzle()``: donat un nom de puzle, retorna un String amb el
  nom del fitxer corresponent al puzle.

  Pressuposa que el nom és vàlid

  Ex. ``composaNomFitxerDeNomPuzle("mate_en_dos")`` → ``"puzle_mate_en_dos.txt"``

* ``llegeixPuzle()``: donat un nom de puzle, llegeix el fitxer i
  retorna un array d'arrays de caràcters representant el taulell.

  Per exemple, si la crida és ``char[][] taulell =
  llegeixPuzle("negres_mmate_en_un")`` llegirà del fitxer
  ``puzle_negres_mate_en_un.txt`` i retornarà el seu contingut en forma
  d'array d'arrays de caràcters.

  Pressuposarà que el fitxer existeix i que el seu contingut està en el
  format esperat.

* ``existeixPuzle()``: donat un nom de puzle vàlid retorna cert quan
  existeix un fitxer amb aquest nom.

* ``mostraTaulell()``: donat un taulell (``char[][]``) el mostra per
  sortida estàndard.

   Atenció: aquest mòdul s'ha de trobar dins de la classe ``Escacs`` que
   vas desenvolupar als exercicis d'escacs començant per :doc:`aquest
   <exercici_02_31_escacs>`.

Pistes per la implementació
===========================

Aquesta comanda presenta una nova dificultat: té un argument.

Donat que el problema està construït de manera que els nom dels puzles 
no puguin contenir espais, podem limitar-nos a fer servir ``split()`` de
String.

Si vols, pots fer servir la següent nova versió del ``main()``.

.. code-block:: java
    :linenos:

    public static void main(String[] args) throws IOException {
        mostraBenvinguda();
        while (true) {
            mostraPrompt();
            String resposta = Entrada.readLine().strip();
            if (resposta .isEmpty()) continue;
            String[] elementsComanda = resposta .split("\\s+");
            String comanda = elementsComanda[0];
            if (comanda.equals("quit")) break;
            switch (comanda) {
                case "help": mostraAjuda();
                             break;
                case "ls": mostraLlista();
                           break;
                case "show": processaShow(elementsComanda);
                             break;
                default: mostraErrorComandaDesconeguda();
            }
        }
        mostraComiat();
    }

Fixa't que aquesta nova versió, realitza la separació de paraules dins de
la resposta rebuda. Ho fa amb la ja coneguda funció de Strings
``split()``. A ``split()`` li demanem que separi per ``"\\s+"`` en comptes
de per espais simplement ``" "``.  Fent curta una llarga història,
``split()`` considera l'argument que rep com una *expressió regular*. En
aquest cas el que diu és *seqüència d'un o més caracters blanc (espais,
tabuladors, etc.)*. 

Et proposo que facis l'experiment de veure què retorna ``"show
nom_puzle".split(" ")`` i ``"show nom_puzle".split("\s+")``

Les expressions regulars estan fora de l'abast d'aquest exercici i els
jocs de prova que t'he preparat no es preocupen de passar-te comandes amb
més d'un espai (ni tabuladors) seguit. Així que, si vols, tu tampoc te
n'has de preocupar.

El ``main()`` fa servir ``switch`` per a distingir les diferents
comandes. Si encara no el coneixes, ``switch`` és una manera compacta de
fer condicions. Potser voldràs revisar :doc:`aquest exercici
<exercici_01_19_dies_setmana_switch>`. Per descomptat, si ho prefereixes,
pots continuar encadenant ``if`` amb ``comanda.equals("show")`` i
similars.

Com potser t'imaginaràs, a partir d'ara, afegir noves comandes serà anant
afegint nous ``case``.


Finalment, el meu codi de ``processaShow()`` és el següent:

.. code-block:: java
    :linenos:

    /**
     * Processa la comanda show
     * @param args: arguments de la comanda
     */
    public static void processaShow(String[] args) throws IOException {
        if (args.length != 2) {
            mostraErrorComandaShow();
            return;
        }
        String nomPuzle = args[1];
        if (! esNomPuzleValid(nomPuzle)) {
            mostraErrorNomPuzleNoValid();
            return;
        }
        if (! existeixPuzle(nomPuzle)) {
            mostraErrorPuzleDesconegut();
            return;
        }
        char[][] taulell = llegeixPuzle(nomPuzle);
        Escacs.mostraTaulell(taulell);
    }

Si vols, pots fer-ho servir al teu programa amb les variacions que
consideris.
