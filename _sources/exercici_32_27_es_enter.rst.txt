####################################################
|exerciseicon__T| Exercici 32_27. És enter (modular)
####################################################

.. rubric:: Context

* Carpeta de lliurament: ``32_27_es_enter/``

* Continguts relacionats: :doc:`moduls_variables`

* Com lliurar-lo: :ref:`instruccions <instruccions_git>`

* [✓] Exercici amb :ref:`autoavaluació<descripcio_exercicis_autoavaluacio>`

.. rubric:: Enunciat

Recuperem l'exercici que mostrava si una cadena contenia o no :doc:`un
valor enter
<exercici_31_76_es_enter>` i fem-ne la versió modular

El programa ``EsEnter`` farà pràcticament el mateix que la versió original però
els càlculs els realitzarà una funció anomenada ``esEnter()``, que rebrà
el text corresponent i retornarà un booleà amb el resultat.

Has llegit *pràcticament*? L'exercici original acceptava com a enters,
valors precedits o finalitzats amb espais en blanc. Això presenta el
problema que t'explico a continuació:

Un dels usos més interessants de ``esEnter()`` és que ens ofereix la
possibilitat de saber si ``Integer.parseInt()`` funcionarà o no, abans
d'executar-ho.

Per exemple, considera:

.. code-block:: console

    jshell> Integer.parseInt("   123  ")
    |  Exception java.lang.NumberFormatException: For input string: "   123  "
    |        at NumberFormatException.forInputString (NumberFormatException.java:65)
    |        at Integer.parseInt (Integer.java:638)
    |        at Integer.parseInt (Integer.java:770)
    |        at (#2:1)

Com veus, en  intentar convertir `"   123  "` a enter, ens genera un
error que trenca l'execució.

Per aquesta raó, no podem acceptar que ``esEnter()`` ignori els espais en
blanc, tal i com sí s'esperava del programa ``EsEnter``.  És a dir, la
feina de treure-li els espais caldrà fer-la abans de fer servir
``esEnter()``.

``esEnter()`` estarà definida dins de ``UtilString.java`` i serà
una funció pura.
