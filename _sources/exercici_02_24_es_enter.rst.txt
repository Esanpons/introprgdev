####################################################
|exerciseicon__T| Exercici 02_24. És enter (modular)
####################################################

.. rubric:: Context

* Carpeta de lliurament: ``02_24_es_enter/``

* Continguts relacionats: :doc:`moduls_variables`

* Com lliurar-lo: :ref:`instruccions <instruccions_git>`

* [✓] Exercici amb :ref:`autoavaluació<descripcio_exercicis_autoavaluacio>`

.. rubric:: Enunciat

Recuperem l'exercici que mostrava si una cadena contenia o no :doc:`un
valor enter
<exercici_01_71_es_enter>` i fem-ne la versió modular

El programa ``EsEnter`` farà pràcticament el mateix que la versió original però
els càlculs els realitzarà una funció anomenada ``esEnter()``, que rebrà
el text corresponent i retornarà un booleà amb el resultat.

Has llegit *pràcticament*? L'exercici original acceptava com a enters,
valors precedits o finalitzats amb espais en blanc. Això presenta el
problema que t'explico a continuació:

Un dels usos més interessants de ``esEnter()`` és que ens ofereix la
possiblitat de saber si ``Integer.parseInt()`` funcionarà o no, abans
d'executar-ho.

Per exemple, considera:

.. code-block:: console

    jshell> Integer.parseInt("   123  ")
    |  Exception java.lang.NumberFormatException: For input string: "   123  "
    |        at NumberFormatException.forInputString (NumberFormatException.java:65)
    |        at Integer.parseInt (Integer.java:638)
    |        at Integer.parseInt (Integer.java:770)
    |        at (#2:1)

Com veus, en  intentar convertir `"   123  "` a enter, ens genera un
error que trenca l'execució.

Per aquesta raó, no podem acceptar que ``esEnter()`` ignori els espais en
blanc, tal i com sí s'esperava del programa ``EsEnter``.  És a dir, la
feina de treure-li els espais caldrà fer-la abans de fer servir
``esEnter()``.

``esEnter()`` estarà definida dins de ``UtilString.java`` i serà
una funció pura.

Ampliació opcional
==================

T'has quedat amb les ganes de fer una versió més flexible de
``esEnter()``. Et proposo que desenvolupis dues noves funcions. Aquí van
les signatures:

.. code-block:: java

    public static boolean esEnter(String text, boolean estricte)

    public static int aEnter(String text, boolean estricte)


El booleà ``estricte`` permetrà decidir el comportament d'aquestes dues
funcions:

* si ``estricte`` és cert

  - ``esEnter(String, boolean)`` es comporta com ``esEnter(String)``

  - ``aEnter(String, boolean)`` es comporta igual que
    ``Integer.parseInt()`` de manera que si el text no es pot convertir a enter,
    simplement *petarà* el programa com ho faria ``Integer.parseInt()``

* si ``estricte`` és fals:

  - ``esEnter(String, boolean)`` acceptarà també texts amb espais a
    l'inici i al final.

  - ``aEnter(String, boolean)`` permetrà convertir a enter, sense donar
    error, texts que continguin espais en blanc a l'inici o/i al final.

Afegeix les dues noves funcions a ``UtilString.java`` de manera que
``prgtest`` pugui avaluar-les.

Et sorprèn que puguis tenir a l'hora ``esEnter(String)`` i
``esEnter(String, boolean)`` amb el mateix nom? És una particularitat
interessant de llenguatges com Java, anomenada *sobrecàrrega* o
*overloading*, que veurem amb més detall en el futur. Si la curiositat no
et deixa dormir, fes una cerca de "java overloading".

Atenció: ``prgtest`` no comprovarà aquesta ampliació. Et ve de gust crear
els tests? Parla amb el teu docent, que està desitjant explicar-t'ho ;)
